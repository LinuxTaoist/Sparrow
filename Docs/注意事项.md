[TOC]
# 约束

## 项目结构与组织
### 为方便第三方库管理，各模块使用第三方库时，有如下约束：
* 第三方库源码，统一放在```Sparrow/3rdParty```目录下，提供源码压缩文件、头文件和静态库文件（参考```libgo```）。
* 模块使用第三方库时，不允许直接调用第三方接口。必须将第三方库封装成接口，提供给模块调用。封装文件放在```Sparrow/Adapter```目录（即第三方库的头文件仅允许在```Sparrow/Adapter```下体现）。此举是为降低工程与第三方库代码耦合，且方便替换第三方库。
* 在开始编译时，需要先独立交叉编译第三方库。

## 编码风格与规范
参考[C++编码规范](C++编码规范.md)

## 模块化与依赖管理
### 为适配不同平台，硬件控制接口，有如下约束：
* 由应用定义统一的一套接口函数，实现接口由各平台继承实现。代码统一放在```Sparrow/HardWare```目录。
* 由于需要兼容不同平台，对接口函数的定义要求就很严格，需做到业务接口定义清晰，接口参数定义清晰，接口返回值定义清晰，接口调用方式清晰，接口调用顺序清晰。

## 平台适配与硬件接口

## 系统启动与生命周期管理
### 为方便控制开机、关机(待机)的业务时序，各模块初始化和销毁有如下约束：
* 业务模块业务初始化接口尽量不放在构造中，在```StartWork()```中调用，接收到 **（开机）** 通知触发调用；同理，模块业务销毁接口在```StopWork()```中调用，接收到 **（关机或待机）** 通知触发调用。
* 工具模块初始化接口可以放在构造中，此做法是为减少外部接口（不用额外调用初始化接口），方便使用者调用。
* 开机时，有些模块需要等待其他模块 **（例如数据库模块）** 的初始化接口调用完成，才能继续调用自身初始化接口，所以初始化需要分优先级。
* 关机时，有些模块需要等待其他模块的接口调用完成，才能继续调用自身的接口，所以需要等待其他模块的消息通知。
* 若模块开机时5s内 **（时间可配置）** 未收到开机消息，需要自行调用调用初始化。
* 当模块启动依赖其他模块时，需要有时序控制，确保依赖的模块先启动，同时确保各模块可重入（安全退出，重新启动）。

## 并发与线程模型
### 为方便线程控制，各模块使用线程时有如下约束：
* 工程已提供```libgo```库，其中有提供协程接口，尽量用协程接口代替线程。
* 如必须使用线程，若线程存在```loop```（循环函数），必须可正常退出，避免死循环导致无法回收。
* 线程退出后必须回收，且尽可能使用```join()```而非```detach()```。（调用```detach()```，线程并未退出甚至一直未退出）

## 内存与资源管理
### 为避免内存泄露，动态分配内存时，有如下约束：
* 尽量使用智能指针分配内存，如```std::shared_ptr```、```std::unique_ptr```等。
* 尽量使用```make_shared```、```make_unique```等函数分配内存，避免手动调用```new```。
* 如必须使用```new```，必须使用```delete```释放内存, 释放后指针置为```nullptr```。

