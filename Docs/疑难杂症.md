[TOC]

# 疑难杂症

## 组件依赖与初始化顺序
**问题描述**
&emsp; 组件之间的依赖关系错综复杂。当组件A依赖于组件B的特定状态或服务时，如果B的初始化过程较为缓慢或者出现错误，会导致A在未准备好的状态下尝试使用B的服务，引发运行时错误。

**解决方案**
1. 从启动策略规避。依赖图构建与启动策略优化：
   * 首先，构建详尽的组件依赖图谱，明确各组件间的依赖关系和启动顺序。
   * 引入依赖检查机制于启动脚本中，确保仅在所有前置依赖组件成功初始化并设置完成标识后，后续组件方才启动，以此序列化执行，保障初始化流程的有序进行。
   * 具体参考`ServiceManager::StartAllExesFromConfigure`。
2. 从组件内部规避。异步初始化与事件通知机制
   * 对于初始化耗时较长的组件行为，可采取异步初始化策略。完成初始化行为后，通过异步消息通知其他组件。
   * 存在依赖关系的组件，接收到前置依赖行为完成消息后，再执行初始化行为。
3. 从监控日志定位：
   * 对各组件初始化行为“打桩”，记录关键步骤的完成状态和耗时，便于问题定位与优化。

### 触发组件安全退出机制时，出现部分进程crash
**问题描述**
&emsp; 终端输入`killall -10 servicemanagersrv`，触发组件安全退出机制，发现 `/dev/shm/`路径下仍残留大量文件，溯源发现是由于部分进程在退出时出现crash，导致未正常回收资源。
```
$ killall -10 servicemanagersrv
$ ls /dev/shm/
sem.OneNetMqtt_req33372  sem.OneNetMqtt_rsp33372  sem.property_service_req79933
sem.OneNetMqtt_req40994  sem.OneNetMqtt_rsp40994  sem.property_service_rsp79933
```

**解决方案**
1. 分析:
    ① 在触发组件安全退出机制时，发现部分进程在退出时出现crash，导致未正常回收资源。
    ② 在程序行结束，各模块对象进入析构时，出现静态单例对象析构调用另一个静态单例对象（已销毁），导致crash。
2. 解决:
    ① 增加静态原子变量标记对象是否已销毁。
    ② 避免单例对象调用析构：
    ```c++

    ```


## 代码复用与项目差异化
**问题描述**
&emsp; 需在多个项目中复用同一套代码，同时满足各项目特有的功能需求差异。

**解决方案**
* 模块化设计。将代码模块化，利用接口、抽象类等定义通用接口，并为不同项目实现具体的适配或扩展。
* 配置驱动开发。使用配置文件或参数化设计，使得同一套代码可以根据配置文件或参数的不同行为有所不同 (参考配置`ProjectConfigs/Vendor`)。

## 分支管理与迭代开发
**问题描述**
&emsp; 项目开发中面临多线程任务开发，包括维护稳定版本、新增功能开发及新项目启动，需避免并行开发引起的版本冲突。

**解决方案**
* 版本控制策略。使用适当的分支策略，如主分支用于稳定版本维护，开发分支用于新功能开发，每个功能或修复任务都从主分支拉取新分支，开发完成后再合并回主分支。
* 持续集成与部署： 实施持续集成与持续部署（CI/CD），确保代码集成频繁且自动化测试通过，减少集成时的冲突和延迟。

## 项目配置数据遗失
**问题描述**
&emsp; 项目目配置数据（如数据库连接字符串、第三方API密钥、环境变量等）意外丢失或被错误地覆盖，导致系统无法正常运行，服务中断或功能失效。

**解决方案**
* 安全存储与备份。使用安全的配置管理工具和策略，确保配置数据安全存储、备份和恢复能力。
* 版本控制配置。将配置数据也纳入版本控制系统管理，确保配置的变更可追溯和回滚。

## 测试覆盖率及验收不充分
**问题描述**
&emsp; 系统复杂性增加，自动化测试案例匮乏，覆盖率低，不能过早的及时暴露潜在问题。

**解决方案**
* 全面的测试策略。制定全面的测试计划，包括单元测试、集成测试、系统测试和性能测试等，确保不同层面的测试覆盖。
* 自动化测试工具。使用自动化测试工具和框架，提高测试覆盖率和持续集成效率。
* 建立完善的自动化测试流程。明确每个案例输入输出，实现自动化比对机制（如断言），验证实际输出与预期输出的一致性，记录测试报告。

## 动态阈值管理机制
**问题描述**
&emsp; 在系统设计初期，针对所有动态不定容量的数据，应设置阈值上限，以防止数据量过大导致系统崩溃。然而，随着时间推移和业务增长，实际数据量可能接近甚至超过最初设定的阈值上限，从而影响业务正常运行。

**解决方案**
* 动态阈值调整。设计系统时内置动态调整机制，根据实际数据增长趋势与系统负载能够自动调整存储与处理能力的阈值，同时触发预警机制。


## 各模块共用数据类型管理
**问题描述**
&emsp; 在系统集成与调试过程中，常出现共用数据类型(共用枚举类型，数据结构)变更，未能及时在各组件间同步，导致通信故障并难以排查。

**解决方案**
1. 集中管理共用数据类型。将所有跨组件的共用数据定义放置在一个文件中进行管理，并确保所有组件共享此文件。这样，在任何数据类型修改时，集成编译过程能够自动同步更新。（参考`CommonMacros.h`、`CommonTypeDefs.h`、`CoreTypeDefs.h`）
2. 引入版本号。在局部模块升级场景中，第1步仍会存在各组件共用数据类型不一致。考虑这种情况，涉及在共用定义文件中加入一个版本号宏，并要求各组件保存此版本号。每次修改共享数据类型时，同时更新版本号。通过比较各组件使用的版本号，能够问题现场快速定位通信异常问题 (参考宏`COMMON_MACROS_VERSION`、`COMMON_TYPE_DEFS_VERSION`、`CORE_TYPE_DEFS_VERSION`)。
3. 兼容性考虑。考虑到即使出现版本不统一，仍最小化影响各组件业务。建议在修改消息枚举时尽量只增加新的枚举值，避免修改现有枚举值。例如，可以在枚举的尾部增加新值，确保对现有枚举值不造成影响（此种措施仅针对枚举类型有效）。

## 异地测试与开发协同
**问题描述**
&emsp; 异地测试开发协同中，存在跨地域沟通壁垒，导致故障不能即时反馈、精准定位与高效调试。

**解决方案**
* 远程调试与监控。实施远程调试和实时监控系统，能够远程定位和解决问题，减少因地理距离带来的延迟（参考`Debug/RShellX`）。
* 增加一键日志导出功能，提供给测试人员快捷方式，能够快速导出现场日志，最好包含在线式和离线式两种方式。

## 编译报错

### 编译报错 undefined reference to symbol 'sem_close@@GLIBC_2.2.
**问题描述**
&emsp; 编译报错 `undefined reference to symbol 'sem_close@@GLIBC_2.2.5'`

**解决方案**
* `sem()`位于`pthread`库中，检查编译脚本是否链接pthread库文件。
* 若库之间存在链接依赖，在`CMake`使用`target_link_libraries`时，被依赖的库顺序应靠后。

### 交叉编译bin文件在arm上运行报错“/bin/sh: ./servicemanagersrv: not found”

**问题描述**
&emsp; 交叉编译生成的bin文件，arm执行时报错“/bin/sh: ./servicemanagersrv: not found”

**解决方案**
* 通过 "file servicemanagersrv" 命令查看文件类型，对比正常可执行的bin文件。

```shell
$ file servicemanagersrv
servicemanagersrv: ELF 32-bit LSB shared object, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.3, for GNU/Linux 3.2.0, BuildID[sha1]=86aab950869c071d3834ac5ed1d2a4d7dc055fa8, with debug_info, not stripped

$ file test
test: ELF 32-bit LSB shared object, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-armhf.so.3, for GNU/Linux 3.2.0, BuildID[sha1]=cc78a66419f729997043cb1b236ada4a8c5bfa0b, stripped
```
* 对比发现，两者interpreter有差异。在CMake中将`servicemanagersrv`的interpreter修改为`/lib/ld-linux-armhf.so.3`。

```shell
set(CMAKE_EXE_LINKER_FLAGS "-Wl,-dynamic-linker,/lib/ld-linux-armhf.so.3")
```
* 重新编译运行，问题解决。
